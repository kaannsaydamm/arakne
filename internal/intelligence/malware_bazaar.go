package intelligence

import (
	"arakne/internal/core"
	"archive/zip"
	"encoding/csv"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// UpdateMalwareBazaar downloads and integrates the full MalwareBazaar CSV export
func UpdateMalwareBazaar(db *HashDatabase) {
	// 1. Check if we should update (e.g., limit frequency)
	// For now, we update on every startup if internet is available, but user can kill it if slow.
	// Ideally check file age if we kept the zip.

	url := "https://bazaar.abuse.ch/export/csv/full/"
	fmt.Println("[*] MalwareBazaar: Starting background download of FULL database...")

	// 2. Download to temp file
	tmpFile, err := os.CreateTemp(core.TempDir, "mb_full_*.zip")
	if err != nil {
		fmt.Printf("[!] MalwareBazaar: Failed to create temp file: %v\n", err)
		return
	}
	defer os.Remove(tmpFile.Name()) // Clean up
	defer tmpFile.Close()

	client := &http.Client{Timeout: 30 * time.Minute} // Huge file, long timeout
	resp, err := client.Get(url)
	if err != nil {
		fmt.Printf("[!] MalwareBazaar: Download failed: %v\n", err)
		return
	}
	defer resp.Body.Close()

	// Progress indicator? Minimal.
	_, err = io.Copy(tmpFile, resp.Body)
	if err != nil {
		fmt.Printf("[!] MalwareBazaar: Write failed: %v\n", err)
		return
	}

	// 3. Unzip
	zipReader, err := zip.OpenReader(tmpFile.Name())
	if err != nil {
		fmt.Printf("[!] MalwareBazaar: Invalid ZIP: %v\n", err)
		return
	}
	defer zipReader.Close()

	if len(zipReader.File) == 0 {
		return
	}

	// Find the CSV file
	var csvFile *zip.File
	for _, f := range zipReader.File {
		fmt.Printf("[DEBUG] ZIP Content: %s (%d bytes)\n", f.Name, f.UncompressedSize64)
		if strings.HasSuffix(f.Name, ".csv") {
			csvFile = f
			break
		}
	}

	if csvFile == nil {
		fmt.Println("[!] MalwareBazaar: No .csv file found in ZIP.")
		// Fallback to first file if no .csv extension?
		csvFile = zipReader.File[0]
	}

	f := csvFile
	rc, err := f.Open()
	if err != nil {
		fmt.Printf("[!] MalwareBazaar: Failed to open CSV in ZIP: %v\n", err)
		return
	}
	defer rc.Close()

	// 4. Parse CSV
	fmt.Println("[*] MalwareBazaar: Parsing CSV data...")

	reader := csv.NewReader(rc)
	reader.Comment = '#'        // Skip comments
	reader.FieldsPerRecord = -1 // Variable fields allowed (ignoring extra)
	reader.LazyQuotes = true    // Allow quotes in non-quoted fields (critical fix)

	newBad := make(map[string]string)

	count := 0
	debugPrinted := false
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			if count < 5 {
				fmt.Printf("[DEBUG] CSV Error: %v\n", err)
			}
			continue
		}

		// Expected format checks
		if len(record) > 1 {
			// Debug first record
			if !debugPrinted {
				fmt.Printf("[DEBUG] First Record: %v\n", record)
				debugPrinted = true
			}

			sha256 := strings.TrimSpace(record[1])
			sha256 = strings.Trim(sha256, "\"'") // Strip quotes
			if len(sha256) == 64 {               // specific length check
				label := "MalwareBazaar/Unknown"
				if len(record) > 8 {
					val := record[8]
					if val != "" && val != "n/a" {
						label = "MalwareBazaar/" + val
					} else if len(record) > 6 {
						// file_type is index 6
						label = "MalwareBazaar/" + record[6]
					}
				}
				newBad[sha256] = label
				count++
			} else {
				if count == 0 {
					fmt.Printf("[DEBUG] Skipped invalid hash len=%d: %s\n", len(sha256), sha256)
				}
			}
		}
	}

	fmt.Printf("[+] MalwareBazaar: Parsed %d malware hashes. Merging...\n", count)
	db.MergeKnownBad(newBad)
	fmt.Println("[+] MalwareBazaar: Accession Complete.")
}
